# 并发术语

如果两个或者多个 goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（racecandition）。对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个goroutine对共享资源进行读和写操作。



一种修正代码、消除竞争状态的办法是，使用 Go 语言提供的锁机制，来锁住共享资源，从 而保证 goroutine 的同步状态。Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。如果需要顺序访问一个 整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。





　**进程、线程 和 协程 之间概念的区别**

　对于 **进程、线程**，都是有内核进行调度，有 CPU 时间片的概念，进行 **抢占式调度**（有多种调度算法）

　对于 **协程**(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 **协作式调度**，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。

**本质上，goroutine 就是协程。** 



不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。

Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。



内存消耗方面

每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。
　　　　*goroutine：*2KB 
　　　　线程：8MB

线程和 goroutine 切换调度开销方面

　　线程/goroutine 切换开销方面，goroutine 远比线程小
　　　　*线程：*涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。
　　　　*goroutine：*只有三个寄存器的值修改 - PC / SP / DX.



线程是操作系统的内核对象，多线程编程时，如果线程数过多，就会导致频繁的上下文切换，这些 cpu 时间是一个额外的耗费。

所以在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 连接是很不明智的。

于是操作系统提供了基于事件模式的异步编程模型。

用少量的线程来服务大量的网络连接和I/O操作。

但是采用异步和基于事件的编程模型，复杂化了程序代码的编写，非常容易出错。

因为线程穿插，也提高排查错误的难度。





协程，是在应用层模拟的线程，他避免了上下文切换的额外耗费，兼顾了多线程的优点。

简化了高并发程序的复杂度。

举个例子，一个高并发的网络服务器，每一个socket连接进来，服务器用一个协程来对他进行服务。代码非常清晰。而且兼顾了性能。



 **那么，协程是怎么实现的呢？**

他和线程的原理是一样的，当 a线程 切换到 b线程 的时候，需要将 a线程 的相关执行进度压入栈，然后将 b线程 的执行进度出栈，进入 b线程 的执行序列。

协程只不过是在 应用层 实现这一点。

但是，协程并不是由操作系统调度的，而且应用程序也没有能力和权限执行 cpu 调度。怎么解决这个问题？

答案是，协程是基于线程的。

内部实现上，维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。

这就解决了协程的执行问题。那么协程是怎么切换的呢？

答案是：golang 对各种 io函数 进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 io函数，当这些异步函数返回 busy 或 bloking 时，golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。

包括 linux 的 epoll、select 和 windows 的 iocp、event 等。



由于golang是从编译器和语言基础库多个层面对协程做了实现，所以，golang的协程是目前各类有协程概念的语言中实现的最完整和成熟的。

十万个协程同时运行也毫无压力。关键我们不会这么写代码。但是总体而言，程序员可以在编写 golang 代码的时候，可以更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。



协程（Coroutine）是在1963年由Melvin E. Conway USAF, Bedford, MA等人提出的一个概念。而且协程的概念是早于线程（Thread）提出的。

但是由于协程是**非抢占式**的调度，无法实现公平的任务调用。也无法直接利用多核优势。因此，我们不能武断地说协程是比线程更高级的技术。



尽管，在任务调度上，协程是弱于线程的。

但是在资源消耗上，协程则是极低的。

一个线程的内存在 MB 级别，而协程只需要 KB 级别。

而且线程的调度需要内核态与用户的频繁切入切出，资源消耗也不小。

我们把协程的基本特点归纳为：

```
`1. 协程调度机制无法实现公平调度``2. 协程的资源开销是非常低的，一台普通的服务器就可以支持百万协程。`
```



那么，近几年为何协程的概念可以大热。

我认为一个特殊的场景使得协程能够广泛的发挥其优势，并且屏蔽掉了劣势 --> 网络编程。

与一般的计算机程序相比，网络编程有其独有的特点。

```
`1. 高并发（每秒钟上千数万的单机访问量）``2. Request/Response。程序生命期端（毫秒，秒级）``3. 高IO，低计算（连接数据库，请求API）。`
```

最开始的网络程序其实就是一个线程一个请求设计的（Apache）。

后来，随着网络的普及，诞生了C10K问题。Nginx 通过单线程异步 IO 把网络程序的执行流程进行了乱序化，通过 IO 事件机制最大化的保证了CPU的利用率。

至此，现代网络程序的架构已经形成。基于IO事件调度的异步编程。其代表作恐怕就属 `NodeJS `了吧。



在工程上，有两种最常见的并发通信模型：**共享内存** 和 **消息**。

使用了锁变量（属于一种共享内存）来同步协程，事实上 Go 语言主要使用消息机制（channel）来作为通信模型



在UNIX中，select()函数用来监控一组描述符，该机制常被用于实现高并发的socket服务器程序。

Go语言直接在语言级别支持select关键字，用于处理异步IO问题



Goland 并发实现

1. goruntine: 程序并发执行

2. channel: 多个goruntine间的数据同步和通信

3. select: 多个channel选择数据读取或者写入

   

在单机系统中，trylock并不是一个好选择。

因为大量的goroutine抢锁可能会导致CPU无意义的资源浪费。

有一个专有名词用来描述这种抢锁的场景：活锁。

活锁指的是程序看起来在正常执行，但实际上CPU周期被浪费在抢锁，而非执行任务上，从而程序整体的执行效率低下。

活锁的问题定位起来要麻烦很多。所以在单机场景下，不建议使用这种锁。



并发不是并行: Concurrency Is Not Parallelism

并发主要是由切换时间片来实现"同步"执行

并行是直接使用多核实现的多线程的运行(单核计算机不存在并行)

Go还可以设置核数,以发挥多核的威力



Goroutine 奉行通过通信来共享内存,而不失共享内存来通信

Do not communicate by sharing memory, instead,share memory by communicat



1. 一个线程绑定到一个逻辑处理器上，多个协程被添加到逻辑任务队列中，由go运行时调度器进行调度，当有一个协程调用了系统blocking syscall后，这个线程就会从该逻辑处理器中卸下来，继续等待，调度器会再创建一个线程来绑定到该逻辑处理器上，并从运行队列中挑选一个go协程来运行。
2. 若一个go协程需要进行一个网络I/O调用，那么该协程就会从逻辑处理器上卸下来并转移到由go运行时构造的网络轮询器上，当轮询器检测到读或写操作准备好后，该go协程就会重新调度到逻辑处理器上去处理相应的操作
3. 默认的运行时可以启动的线程数是10000，这个值可以通过SetMaxThreads方法更改，当线程数超过最大值，程序将崩溃。
4. 并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。
5. 并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。
6. 若想go协程真正的并行运行，那么就必须运行的多物理处理器的机器上若机器只有一个处理器，就算是多线程也只是并发而已



进程是内存资源管理和cpu调度的执行单元。

为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。

协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。



goruntine 就可以看作用户的"线程池"



最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。



现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），传统的协程库属于**用户级线程模型**，而goroutine和它的`Go Scheduler`在底层实现上其实是属于**两级线程模型**



互联网时代以降，由于在线用户数量的爆炸，单台服务器处理的连接也水涨船高，迫使编程模式由从前的串行模式升级到并发模型，而几十年来，并发模型也是一代代地升级，有IO多路复用、多进程以及多线程，这几种模型都各有长短，现代复杂的高并发架构大多是几种模型协同使用，不同场景应用不同模型，扬长避短，发挥服务器的最大性能，而多线程，因为其轻量和易用，成为并发编程中使用频率最高的并发模型，而后衍生的协程等其他子产品，也都基于它，而我们今天要分析的 goroutine 也是基于线程，因此，我们先来聊聊线程的三大模型：

线程的实现模型主要有3种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），它们之间最大的差异就在于用户线程与内核调度实体（KSE，Kernel Scheduling Entity）之间的对应关系上。而所谓的内核调度实体 KSE 就是指可以被操作系统内核调度器调度的对象实体（这说的啥玩意儿，敢不敢通俗易懂一点？）。简单来说 KSE 就是内核级线程，是操作系统内核的最小调度单元，也就是我们写代码的时候通俗理解上的线程了



协程比线程更为轻量。

默认情况中一个进程最大可以启动254个线程，这个数值也可以改为无限制，但主机资源消耗会非常严重。

而使用协程就不同了，一个进程可以轻轻松松启动上万个协程而毫无压力。



golang设计协程的目的，一方面是为了提高并发效率，另外一方面就是尽可能发挥多核CPU的能力。

golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。

通过这样的设计，把每个CPU都充分调动起来，减少CPU空闲时间，提高了CPU吞吐量，无形当中也提高了I/O效率。



在golang并发模型中，存在两个概念：Fan-in(扇入)和Fan-out(扇出)。

扇入指的是一个程序可以同时从多个channel中读取数据并且对其进行处理，直到收到明确的停止信号或者所有的channel被关闭。 

扇出指的是多个程序可以同时从一个channel中读取数据并且对其进行处理，直到channel关闭。

扇出值越大，CPU利用率越高，IO使用率也就越高。



何谓死锁? [操作系统](http://lib.csdn.net/base/operatingsystem)有讲过的，所有的线程或进程都在等待资源的释放。



在Go语言中，每一个并发的执行单元叫作一个goroutine。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。

当主函数返回时，所有的goroutine都会直接打断，程序退出。除了从主函数退出或者直接退出程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是我们之后可以看到，可以通过goroutine之间的通信来让一个goroutine请求请求其它的goroutine，并让其自己结束执行。

