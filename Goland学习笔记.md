1. Go 是一门零值语言,Go语言中不存在未初始化的变量

   当向map中查询不存在的key时,以零值操作

   当向map中添加不存在的key时,

   - 如果初始化,则以零值为默认值
   - 如果未初始化,则 `panic`

   ```go
   	m := map[string]int{} //声明并初始化
   	fmt.Println(m == nil) // false
   	fmt.Println(m["a"]) // 0
   	m["b"]++
   	fmt.Println(m["b"]) // 1
   
   	var n map[string]int // 只是声明,未初始化
   	fmt.Println(n == nil) // true
   	fmt.Println(n["a"]) // 0
   	n["b"]++
   	fmt.Println(n["b"]) // panic
   ```

   当结构体具有map字段时，就要当心了，因为在向其添加条目之前必须对其进行初始化。

2. 自 Go 1.5开始， Go的`GOMAXPROCS`默认值已经设置为 CPU的核数， 这允许我们的Go程序充分使用机器的每一个CPU

3. switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较

4. 包中定义的包一级(函数外)函数,变量,类型,常量,在包中的任意文件均可以使用

   包中大写的包一级(函数外)函数,变量,类型,常量,在包外可以引用

   对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的

5. 简短类型变量声明,可以重复声明一个相同作用域中的变量

   ```go
   in, err := os.Open(infile)
   // ...
   out, err := os.Create(outfile)
   ```

   简短变量声明语句中必须至少要声明一个新的变量

6. 编译器会**自动选择在栈上还是在堆上分配局部变量的存储空间**

7. 函数的右小括号也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号

8. 除了关键字,其他内置常量,类型,函数,都可以重新赋值

9. 只存在 i++,i-- 并且赋值表达式不返回值

10. go的初始化执行顺序:

    1. 先执行导入包的包一级变量的初始化,包以文件名顺序
    2. 再执行导入包中的init函数,一个文件中的init函数可以有多个,以声明顺序执行
    3. 再执行本包中的包一级变量的初始化
    4. 再执行本包中的init函数
    5. 再执行本包中的main函数

11. Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

    - 基本类型: int,bool,string,float,complex,rune

      常量的值只能是基本类型

    - 复合类型: struct, array

      数组和结构体都是有固定内存大小的数据结构。

    - 引用类型: slice,map,pointer,map,channel,func

      slice和map是动态的数据结构，它们将根据需要动态增长。

      对任一引用类型数据的修改都会影响所有该引用的拷贝

    - 接口类型: interface

12. 字符串可使用判断运算符,比较通过逐个字节比较完成的

13. 数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。

    不相等比较运算符!=遵循同样的规则。

    只有长度相同 且 类型相同的数组才可以进行判断操作,不然直接在编辑时报错

14. 因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：

    ```Go
    s[0] = 'L' // compile error: cannot assign to s[0]
    ```

15. 一个原生的字符串面值形式是\`...\`，使用反引号代替双引号。

    **在原生的字符串面值中，没有转义操作；**全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行,原生字符串面值用于编写正则表达式或者多行字符串会很方便

16. UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。

17. 标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。

    strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

    bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效。

    strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。

    unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。

18. **如果省略初始化表达式则表示使用前面常量的初始化表达式的值法**。

    ```Go
    const (
        a = 1 // 1
        b     // 1
        c = 2 // 2
        d     // 2
    )
    
    const (
    	a = 1 //1
    	b		  //1
    	c     //1
    	d     //1
      _
    	e = iota //5
    	f        //6
    )
    ```

    在一个const声明语句中，**在第一个声明的常量所在的行，iota将会被置为0**，**然后在每一个有常量声明的行加一。(不管你是从哪一行开始使用 iota)**

19. 无类型的常量不仅可提供更高的运算精度，而且可以直接用于更多的表达式**而不需要显式的类型转换**。

    **常量的数值可以当作任何类型使用**

20. if switch 中可以定义变量,变量的作用域只在 语句中有效

    switch 中会自动 break , 除非使用 fallthrough

21. 可以指定一个索引和对应值列表的方式初始化

    ```Go
    const (
        USD Currency = iota // 美元
        EUR                 // 欧元
        GBP                 // 英镑
        RMB                 // 人民币
    )
    
    symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
    
    fmt.Println(RMB, symbol[RMB]) // "3 ￥"
    ```

22. Go语言是值类型传递

    所以,当传递大的数组时,会很低效

    虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。

23. 一个slice由三个部分构成：指针、长度和容量。

    指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。

    长度对应slice中元素的数目；长度不能超过容量，

    容量一般是从slice的开始位置到底层数据的结尾位置。

24. **如果切片操作超出cap(s)的上限将导致一个panic异常，**

    **但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大**

    扩展后的slice和原来的slice不是同一个引用了

25. slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。

26. 和数组不同的是，slice之间不能比较

    如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。

27. 内置的make函数创建一个指定元素类型、长度和容量的slice。

    **容量部分可以省略，在这种情况下，容量将等于长度。**

28. 内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。

    **copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度**

29. 其中map的K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。

    slice , map , function 不可以作为key

    struct 不包含上述类型字段,也可以作为key

30. 不能对map的元素进行取址操作:禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。

31. Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。

32. slice,map只能和nil比较

33. 如果结构体没有任何成员的话就是空结构体，写作struct{}。

    **它的大小为0，也不包含任何信息，但是有时候依然是有价值的。**

    有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。

    或者是空的channel

34. 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。

    相等比较运算符==将比较两个结构体的每个成员

35. 你可能会偶尔遇到没有函数体的函数声明，**这表示该函数不是以Go实现的**。

    ```go
    package math
    
    func Sin(x float64) float //implemented in assembly language
    ```

36. 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。

    固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；

    除此之外，还会导致安全性问题。

    与此相反，Go语言使用可变栈，栈的大小按需增加(初始时很小)。

    这使得我们使用递归时不必考虑溢出和安全问题。

37. 一个值为nil的slice 就可以直接进行apped等操作

38. 下面的代码利用fmt.Printf的一个小技巧控制输出的缩进。

    ```Go
     fmt.Printf("%*s</%s>\n", depth*2, "", n.Data)
    ```

    `%*s`中的`*`会在字符串之前填充一些空格。每次输出会先填充`depth*2`数量的空格，再输出""，最后再输出HTML标签。

39. 在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。其可变形参是一个切片

    如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。

    ```Go
    values := []int{1, 2, 3, 4}
    fmt.Println(sum(values...)) // "10"
    ```

40. return , panic 后会执行该函数的defer函数,执行顺序: 栈模型

41. **被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值**：

    ```Go
    func triple(x int) (result int) {
        defer func() { result += x }()
        return double(x)
    }
    fmt.Println(triple(4)) // "12"
    ```

42. 函数名中的Must前缀是一种针对此类函数的命名约定 , 如果不合法就panic

43. 在声明方法时，**如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的**，比如下面：

    ```go
    type P *int
    func (P) f() { /* ... */ } // compile error: invalid receiver type
    ```

    1. 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
    2. 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。

44. 内嵌字段可以有两种方式访问:

    - 变量.类型.值
    - 变量.值

    ```go
    var cp ColoredPoint
    cp.X = 1
    fmt.Println(cp.Point.X) // "1"
    cp.Point.Y = 2
    fmt.Println(cp.Y) // "2"
    ```

45. ```go
    var cache = struct {
        sync.Mutex
        mapping map[string]string
    }{
        mapping: make(map[string]string),
    }
    
    
    func Lookup(key string) string {
        cache.Lock()
        v := cache.mapping[key]
        cache.Unlock()
        return v
    }
    ```

46. 反射的结构体中,只有大写的字段是可以设置的

    如果反射的是基本类型,需要在valueOf传进地址

































