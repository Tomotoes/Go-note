

只能是 变量++
   不能是 ++变量



defer 指定的函数是在当前行就调用了的，只是**延迟**到`return`后执行

而不等同于“**移动**”到`return`后执行，因此调用时传递的是当前的参数的值。



多个`defer`指定的函数执行顺序是"先进后出"。栈模型



**Go语言除了map、slice、chan都是值传递**

make 只能声明：map，slice，chan 类型

定义 map 不需要指定长度，通过 make 指定长度也没有意义，map本来就是动态的，即使指定长度没有数据就认为len为0

map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制

make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配

new返回指针, 且值为 nil; new(T)分配了零值填充的T类型的内存空间，并且返回其地址

make返回对象, 且值不为nil; make返回初始化后的（非零）值



golang并发本质

PMG的原理，P对应操作系统进程--对程序的抽象，W对应操作系统线程--对寄存器的抽象， G对应goroutine--go实现的轻量级线程，也即GreenThreads用户态线程。 一句话，golang提供了用户态线程的管理机制。

G通过阻塞方式调用，M不会阻塞，G通过netpoller唤醒。一句话，用户态线程通过netpoller方式避免阻塞系统线程。 当然，其他可能阻塞的地方golang的runtime也会做相应的优化，比如for循环也会被runtime优化。

goroutine+channel的本质是对生产车间流水线的完美模拟，应用开发者只要想清楚流水线该如何设计之后就能轻易理解 goroutine/channel的精妙，gorotine相当于很多干活的人，chennel相当于很多人之前的连线，点和线之间就可以设计复杂的工作流 理解了这一点就可以将问题抽象为，这个活儿能不能多个人一起干（多个goroutine）， 这多个人怎么使用（chennel）有效的组织起来形成流水线？

无缓冲的channel可用于在多个goroutine之间同步，避免了显示的加锁。需要多个goroutine存在才能跑起来，只有一个goroutine会造成死锁

有缓冲的channel是对无缓冲channel的补充，可以作为流水线缓冲队列使用，一定程度上可以减轻无缓冲channel即阻塞式channel的压力，提高流水线的整体性能

等待所有routine完成 需要考虑解决两个问题

使用channel同步等待、使用sync.WaitGroup等待、主线程开goroutine等待并发出done信号，单个worker作为主goroutine

需要安全关闭channel

单worker输出的channel可以由生产者主动关闭

多worker输出的channel可以由第三方主动关闭，但要确认不会出现PANIC

下游goroutine使用for-range等待channel关闭

worker中select监控多个channel数据流动，接收done信号

同一个package属于一个作用域，所以不要重复定义变量等

一个目录下,只能有一个包

rune是int32的别称，byte是uint8的别称



init 函数在main函数执行之前执行,

可以声明多个init函数,执行顺序是"先进先出"。队模型



实现了 `String` 接口的类型 ， 即重写了 该类型变量的打印内容

```go
type myInt int
func (i myInt) String() string{
	return "test"
}
```



原始类型（int | bool | string ...），不可实现接口，必须二次封装原始类型。



实现了 `Error` 接口的类型 ， 即重写了 抛出异常时的内容



break, continue, return, goto 与 C 语言实现一样

switch默认在case之后带break，如果需继续遍历，可以使用fallthrough强制执行后面的case代码

for 既可用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作，Golang中没有while操作符



if switch 代码块内允许声明临时变量在if-else代码块内使用，使用分号；分割多条语句

**只能在声明的代码块中使用**



整型、浮点型、复数默认类型分别为int/float64/complex128

默认值： bool-false, string-"", 整型、浮点型、复数-0 ，slice、map - nil

枚举使用iota进行0值重置

字符串为不可变类型，如果需要改变字符串值，需要转化为[]byte/[]rune切片进行操作

定义数组必须指定长度，且数组长度定义之后不能改变

传值与传址本质都是copy操作，一个copy数据，一个copy地址， copy数据不能改变实参，copy地址通过指针操作可以一定程度上改变实参的值， 但肯定不是随意改变，比如append操作就不会改变原始实参



一个包里面 只能有一个main函数

可以有多个init 函数

init 函数的执行顺序是队列模型

先调用导入包的init 函数, 在调用本包的init函数



结构体初始化时 , 可以指定是否带着键名 , 

如果不带,必须全部初始化.

如果带,可以选择初始化某些键名.



数组长度也是数组类型的一部分 , 因为数组长度不一样的数组, 所包含的内存地址不一样

数组长度不同的数组, 类型不一致



在 go 语言声明的函数和变量前面写注释 , 在使用该函数和变量时, 该注释会变成其文档!

包中,小写的函数和变量都是不可见的 , 大写的都是可见的



数组可以按照索引的方式更改元素

切片引用数组后,切片的修改会同步到数组 , 因为切片内部操作的数组就是引用的数组



切片互相赋值后,所有切片引用的地址都会相同



go 语言的内置函数:

1. append
2. delete
3. len
4. panic
5. recover
6. close
7. make
8. new
9. cap
10. print
11. println
12. imag
13. real

```
append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
close           -- 主要用来关闭channel
delete          -- 从map中删除key对应的value
panic           -- 停止常规的goroutine  （panic和recover：用来做错误处理）
recover         -- 允许程序定义goroutine的panic动作
imag            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
real            -- 返回complex的虚部
make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
new             -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
cap             -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
copy            -- 用于复制和连接slice，返回复制的数目
len             -- 来求长度，比如string、array、slice、map、channel ，返回长度
print、println   -- 底层打印函数，在部署环境中建议使用 fmt 包
```

```
bool
int(32 or 64), int8, int16, int32, int64
uint(32 or 64), uint8(byte), uint16, uint32, uint64
float32, float64
string
complex64, complex128
array    -- 固定长度的数组

slice   -- 序列数组(最常用)
map     -- 映射
chan    -- 管道
```





```
type error interface { 
//只要实现了Error()函数，返回值为String的都实现了err接口
        Error()    String
}
```



range 是一个关键字



struct 的成员可以是任意类型!

如果成员有一个是函数类型 , 外部不可实现同名的函数:





接口和结构体中的成员都不需要分隔符

结构体成员后的 "text" 叫做结构体标签, 也是结构体的一部分 

struct{...}.method()

接口的命名规范, 在名词后添加"er"



一个接口A内 直接包含另一个接口B的名字 , 则A包含B 

实现了B的所有方法并且也实现了A的所有方法,可以让AB同时兼容



一个结构体A内包含另一个结构体B的名字, 则A可以直接调用B的方法





CPU 密集型 , IO密集型



for key := range map

for key,value := range map



常量定义使用 const , 需要注意的是 常量定义时必须初始化, 而初始化的值也只能是一个常量

不能是函数, 变量



可以再 select 中使用 default 实现非阻塞



关闭一个channel , 意味着不能向该通道发送值

在迭代 channel时,通道一定要关闭,不然不知道何时结束,程序会崩溃的

程序会一直等待其他的值发送进通道



一个非空的通道关闭之后,通道中剩下的值仍然可以接收到



```
time.Hour
time.Minute
time.Second

time.Millisecond 毫秒 , 1000 毫秒等于 1 秒
time.Microsecond 微秒 , 1000 微秒等于 1 毫秒 , 1000000 微秒等于 1 秒
time.Nanosecond  纳秒 , 1000 纳秒等于 1 微秒 , 1000000 纳秒等于 1 毫秒 , 1000000000 纳秒等于1秒
```



map 的遍历顺序不固定

recover 只有在 defer 执行的函数中调用才有效

defer func() { recover() }()



**使用 os.Exit 退出时 , defer函数将不会执行**



import alias "path/module"



[*环境变量*](http://zh.wikipedia.org/wiki/环境变量) 是一个[为 Unix 程序传递配置信息](http://www.12factor.net/config)的普遍方式。 

用互斥锁进行了明确的锁定来让共享的 state 跨多个 Go 协程同步访问。

另一个选择是使用内置的 Go 协程和通道的同步特性来达到同样的效果。



排序不会返回值 , 会改变原来的数组



Go的内部排序使用的是快排

string ,根据索引方式输出单个元素时,默认输出 ASCII码

string ,不可以根据索引的方式修改某一元素

必须转换成 整形数组



变量 := 值

只能在函数内使用



程序编译时，先执行导入包的init函数，再执行本包内的init函数

add([]int{1, 3, 7}...)



单个case中，可以出现多个结果选项

只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case



main函数不能带参数

main函数不能定义返回值

main函数所在的包必须为main包

main函数中可以使用flag包来获取和解析命令行参数



``` go
type Slice []int

func NewSlice() Slice {
	return make(Slice, 0)
}
func (s *Slice) Add(elem int) *Slice {
	*s = append(*s, elem)
	fmt.Print(elem)
	return s
}
func main() {
	s := NewSlice()
	defer s.Add(1).Add(2)
	s.Add(3)
}
defer s.Add(1).Add(2)
最后一个Add(2) 就是一个直接执行函数了
so 编译时, 一定是先把 s.Add(1) 给按行执行了
defer 后面, 只把最后一个函数defer了,前置的函数都是按行执行
// s.Add(1) 会先执行 
// 结果: 132
```



go 支持匿名函数!!!

变量 := func(){...}

go 语言中 只有 ++后置 , 没有前置!!!



切片容量必须大于切片长度



在当前协程中, 如果有一个 无缓冲的channel 被读或被写 ,当前协程一定会阻塞

等到其他协程来读或写,才会释放



读写锁可以让多个读操作同时并发，同时读取，但是对于写操作是完全互斥的。

当一个goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。



导入包 , 未使用的话 会报错, 解决方案: import _ "fmt"

声明后, 未使用的变量会报错 , 解决方案: _ = log.Println



```go
one := 0
one, two := 1, 2	// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err
```



- `%+v` 打印包括字段在内的实例的完整信息
- `%#v` 打印包括字段和限定类型名称在内的实例的完整信息
- `%T` 打印某个类型的完整说明



`_test` 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；

只有 gotest 会编译所有的程序：普通程序和测试程序。



goroutine 只是官方实现的"超级线程池"

每个 goroutine 只占用 4-5 kb 的栈内存和大幅减少创建和销毁的开销.是高并发的根本原因



并发不是并行: Concurrency Is Not Parallelism

并发主要是由切换时间片来实现"同步"执行

并行是直接使用多核实现的多线程的运行(单核计算机不存在并行)

Go还可以设置核数,以发挥多核的威力



Goroutine 奉行通过通信来共享内存,而不失共享内存来通信

Do not communicate by sharing memory, instead,share memory by communicat

并发比并行更加优秀



channel

- channel 是 goruntine 沟通的桥梁

- 通过 make 创建 , 通过close销毁

- Channel 是引用类型

- 可使用 for range 来迭代不断操作的 channel(必须close)

- 可设置单向和双向通道(参数传递时)

- 可设置缓存大小, 在未填满前不发生阻塞(可以理解为异步)

  阻塞主要体现在"写操作" , 当有缓存时,写操作不阻塞

  ​					   当无缓存时,写操作阻塞,读完之后,才不阻塞.

  "读操作" 一直是没有数据时,阻塞的; 有数据时,直接读取.

select

- 可处理一个或多个channel的发送与接收
- 同时可有多个可用的channel按随机顺序处理
- **可用空的select来阻塞main函数**
- 可设置超时(time.After)
- case 后必须是 channel的动作(发送或者接收)

```
for{
	selct{
	
	}
}
来实现无限的消息接收发送管理
```



程序的编译阶段

编译->汇编->优化->链接



1. Channel之所以并发安全的原因是通过复制内存的方式来进行共享内存。

2. main.go 文件中 init 方法会在 main 方法之前执行

3. import 语句中的下划线“_”，会初始化后面引入的包，调用包中的init方法, 而不使用该包

4. 引用型的变量不初始化就使用会报错，因为引用变量的默认值是nil

5. 函数传参都是值拷贝

6. 若调用对象为引用类型，函数的接收者为值类型，那么编译器就会自动的进行对象反引用，反之亦然

7. 接口类型的实现可以是某个类的引用类型也可以是值类型

8. 一个线程绑定到一个逻辑处理器上，多个协程被添加到逻辑任务队列中，由go运行时调度器进行调度，当有一个协程调用了系统blocking syscall后，这个线程就会从该逻辑处理器中卸下来，继续等待，调度器会再创建一个线程来绑定到该逻辑处理器上，并从运行队列中挑选一个go协程来运行。

9. 若一个go协程需要进行一个网络I/O调用，那么该协程就会从逻辑处理器上卸下来并转移到由go运行时构造的网络轮询器上，当轮询器检测到读或写操作准备好后，该go协程就会重新调度到逻辑处理器上去处理相应的操作

10. 默认的运行时可以启动的线程数是10000，这个值可以通过SetMaxThreads方法更改，当线程数超过最大值，程序将崩溃。

11. 并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。

12. 并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。

13. 若想go协程真正的并行运行，那么就必须运行的多物理处理器的机器上若机器只有一个处理器，就算是多线程也只是并发而已

14. select 的 case 必须是一个通道操作 , 要么发信号, 要么接收信号

    如果有多个 case 满足条件 , 会随机公平的选取一个满足条件的分支

    如果没有case匹配, 当有 default字句,则执行default,若没有 default,select会阻塞



CSP: Communicating Sequential Process 通信顺序进程



- 重复关闭 channel 会导致 panic。
- 向关闭的 channel 发送数据会 panic。
- 从关闭的 channel 读数据不会 panic，读出 channel 中已有的数据之后再读就是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。

channel 中的值是默认值还是 channel 关闭了。

可以使用 ok-idiom 方式，这种方式在 map 中比较常用。

```go
ch := make(chan int, 10)
...
close(ch)

// ok-idiom 
val, ok := <-ch
if ok == false {
    // channel closed
}
```



进程是内存资源管理和cpu调度的执行单元。

为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。

协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。



goruntine 就可以看作用户的"线程池"



最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。



goroutinue，本质上就是协程。但也存在两点不同：

1. goroutine可以实现并行，也就是说，多个协程可以在多个处理器上跑。

   而协程同一时刻只能在一个处理器上跑（把宿主语言想象成单线程就好了）。

2. goroutine之间通信是通过channel，而协程通信时通过yield和resume()操作。



在java的世界里，并发主要是靠锁住临界资源（共享内存）来保证同步的。



无缓冲的信道永远不会存储数据，只负责数据的流通，为什么这么讲呢？

- 从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞

- 数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞

  

何谓死锁? [操作系统](http://lib.csdn.net/base/operatingsystem)有讲过的，所有的线程或进程都在等待资源的释放。



在Go语言中，每一个并发的执行单元叫作一个goroutine。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。

当主函数返回时，所有的goroutine都会直接打断，程序退出。除了从主函数退出或者直接退出程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是我们之后可以看到，可以通过goroutine之间的通信来让一个goroutine请求请求其它的goroutine，并让其自己结束执行。



现在主流的线程模型分三种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），传统的协程库属于**用户级线程模型**，而goroutine和它的`Go Scheduler`在底层实现上其实是属于**两级线程模型**



互联网时代以降，由于在线用户数量的爆炸，单台服务器处理的连接也水涨船高，迫使编程模式由从前的串行模式升级到并发模型，而几十年来，并发模型也是一代代地升级，有IO多路复用、多进程以及多线程，这几种模型都各有长短，现代复杂的高并发架构大多是几种模型协同使用，不同场景应用不同模型，扬长避短，发挥服务器的最大性能，而多线程，因为其轻量和易用，成为并发编程中使用频率最高的并发模型，而后衍生的协程等其他子产品，也都基于它，而我们今天要分析的 goroutine 也是基于线程，因此，我们先来聊聊线程的三大模型：

线程的实现模型主要有3种：内核级线程模型、用户级线程模型和两级线程模型（也称混合型线程模型），它们之间最大的差异就在于用户线程与内核调度实体（KSE，Kernel Scheduling Entity）之间的对应关系上。而所谓的内核调度实体 KSE 就是指可以被操作系统内核调度器调度的对象实体（这说的啥玩意儿，敢不敢通俗易懂一点？）。简单来说 KSE 就是内核级线程，是操作系统内核的最小调度单元，也就是我们写代码的时候通俗理解上的线程了



协程比线程更为轻量。

默认情况中一个进程最大可以启动254个线程，这个数值也可以改为无限制，但主机资源消耗会非常严重。

而使用协程就不同了，一个进程可以轻轻松松启动上万个协程而毫无压力。



golang设计协程的目的，一方面是为了提高并发效率，另外一方面就是尽可能发挥多核CPU的能力。

golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。

通过这样的设计，把每个CPU都充分调动起来，减少CPU空闲时间，提高了CPU吞吐量，无形当中也提高了I/O效率。



在golang并发模型中，存在两个概念：Fan-in(扇入)和Fan-out(扇出)。

扇入指的是一个程序可以同时从多个channel中读取数据并且对其进行处理，直到收到明确的停止信号或者所有的channel被关闭。 

扇出指的是多个程序可以同时从一个channel中读取数据并且对其进行处理，直到channel关闭。

扇出值越大，CPU利用率越高，IO使用率也就越高。



```go
// 多通道传输数据
ch1 <- <-ch2
```



range 一个channel时, 此channel 一定要close , 不然就会死锁,因为 goruntine会一直等待数据传出



默认地， Go所有的goroutines只能在一个线程里跑，也就是只使用了一个CPU核。

在同一个原生线程里，如果当前goroutine不发生阻塞，它是不会让出CPU时间给其他同线程的goroutines的，这是Go运行时对goroutine的调度，我们也可以使用runtime包来手工调度。



当一个goroutine发生阻塞，Go会自动地把与该goroutine处于同一系统线程的其他goroutines转移到另一个系统线程上去，以使这些goroutines不阻塞



题目说，如下的程序，按照理解应该打印下5次 `"world"`呀，可是为什么什么也没有打印

```go
package main

import (
    "fmt"
)

func say(s string) {
    for i := 0; i < 5; i++ {
        fmt.Println(s)
    }
}

func main() {
    go say("world") //开一个新的Goroutines执行
    for {
    }
}
```

楼下的答案已经很棒了，这里Go仍然在使用单核，for死循环占据了单核CPU所有的资源，而main线和say两个goroutine都在一个线程里面， 所以say没有机会执行。解决方案还是两个：

- 允许Go使用多核(`runtime.GOMAXPROCS`)
- 手动显式调动(`runtime.Gosched`)



关于runtime包几个函数:

- `Gosched` 让出cpu
- `NumCPU` 返回当前系统的CPU核数量
- `GOMAXPROCS` 设置最大的可同时使用的CPU核数
- `Goexit` 退出当前goroutine(但是defer语句会照常执行)





## 开启多核的实验

仍然需要做一个实验，来测试下多核支持下goroutines的对原生线程的分配, 也验证下我们所得到的结论“goroutine不阻塞不放开CPU”。

实验代码如下:

```go
package main

import (
	"fmt"
	"runtime"
)

var quita chan int = make(chan int)

func loop2(id int) { // id: 该goroutine的标号
	for i := 0; i < 10; i++ { //打印10次该goroutine的标号
		fmt.Printf("%d ", id)
	}
	quita <- 0
}

func main() {
	runtime.GOMAXPROCS(2) // 最多同时使用2个核

	for i := 0; i < 3; i++ { //开三个goroutine
		go loop2(i)
	}

	for i := 0; i < 3; i++ {
		<-quita
	}
}
```

多跑几次会看到类似这些输出(不同机器环境不一样):

```
0 0 0 0 0 1 1 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 2 2 2 2



0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2



0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 1 0 1 2 1 2 1 2 2 2 2 2 2 2 2



0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 2 0 2 0 2 2 2 2 2 2 2 2



0 0 0 0 0 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 2 2
```

执行它我们会发现以下现象:

- 有时会发生抢占式输出(说明Go开了不止一个原生线程，达到了真正的并行)
- 有时会顺序输出, 打印完0再打印1, 再打印2(说明Go开一个原生线程，单线程上的goroutine不阻塞不松开CPU)

那么，我们还会观察到一个现象，无论是抢占地输出还是顺序的输出，都会有那么两个数字表现出这样的现象:

- 一个数字的所有输出都会在另一个数字的所有输出之前

原因是， 3个goroutine分配到至多2个线程上，就会至少两个goroutine分配到同一个线程里，单线程里的goroutine 不阻塞不放开CPU, 也就发生了顺序输出。



select 中的 case 后面可以没有表达式, case:



channel类型

1. ch := make(chan <- type)

   ch <- value

2. ch := make(<- chan type)

   <- ch





for _, value := range rand.Perm(3) {
    fmt.Println(value)
}

1 2 0



### [ 格式化输出](https://www.oyohyee.com/post/Note/learn_go/#格式化输出)

输出到控制台使用

```
fmt.Printf()
```

而只需要获得格式化后的字符串使用

```
fmt.sprintf()
```

格式化的替换字符如下:

| 字符     | 含义                                         |
| -------- | -------------------------------------------- |
| `%v`     | 输出结构体的内容                             |
| `%+v`    | 输出结构体的字段名、值                       |
| `%#v`    | 输出结构体的类型、字段名、值                 |
| `%T`     | 输出变量类型                                 |
| `%t`     | 输出布尔值                                   |
| `%d`     | 输出整数                                     |
| `%b`     | 输出二进制整数                               |
| `%c`     | 输出整数对应的ascii字符                      |
| `%x`     | 输出十六进制编码                             |
| `%f`     | 输出浮点数                                   |
| `%e`     | 输出科学计数下的浮点数                       |
| `%E`     | 输出科学计数下的浮点数                       |
| `%s`     | 输出字符串                                   |
| `%p`     | 输出类型                                     |
| `%-a.bf` | 输出左对齐的宽度为`a`且保留`b`位小数的浮点数 |

## [常用包](https://www.oyohyee.com/post/Note/learn_go/#常用包)

### [sort](https://www.oyohyee.com/post/Note/learn_go/#sort)

Go中的sort排序是坐地排序,不会返回值,结果存放在原来的变量中

| 函数                                                         | 备注                                |
| ------------------------------------------------------------ | ----------------------------------- |
| `Float64s(a []float64)`                                      | 排序float类型                       |
| `Float64sAreSorted(a []float64) bool`                        | 返回float是否排序完毕               |
| `Ints(a []int)`                                              | 排序int类型                         |
| `IntsAreSorted(a []int) bool`                                | 返回int类型是否排序完毕             |
| `Search(n int, f func(int) bool) int`                        | 使用二分查找搜索某个值(不存在返回n) |
| `SearchFloat64s(a []float64, x float64) int`                 | 使用二分查找在float中搜索某个值     |
| `SearchInts(a []int, x int) int`                             | 使用二分查找在int中搜索某个值       |
| `SearchStrings(a []string, x string) int`                    | 使用二分查找在string中搜索某个值    |
| `Slice(slice interface{}, less func(i, j int) bool)`         | 自定义类型排序                      |
| `SliceIsSorted(slice interface{}, less func(i, j int) bool) bool` | 自定义类型是否排序完毕              |
| `SliceStable(slice interface{}, less func(i, j int) bool)`   | 自定义类型稳定排序                  |
| `Strings(a []string)`                                        | 排序strings类型                     |
| `StringsAreSorted(a []string) bool`                          | 返回string是否排序完毕              |

### [strings](https://www.oyohyee.com/post/Note/learn_go/#strings)

Go中的字符串处理包

| 函数                                                     | 备注                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| `Compare(a, b string) int`                               | 比较两个字符串大小(字典序)                                   |
| `Contains(s, substr string) bool`                        | 判断一个子串是否在字符串中                                   |
| `ContainsAny(s, chars string) bool`                      | 子串中是否有字符在字符串中存在                               |
| `ContainsRune(s string, r rune) bool`                    | 判断字符是否在字符串中存在(字符以ASCII传入)                  |
| `Count(s, substr string) int`                            | 计算子串在字符串中出现的次数                                 |
| `EqualFold(s, t string) bool`                            | 比较小写的utf-8编码是否相等                                  |
| `Fields(s string) []string`                              | 按照空格将字符串分割成列表                                   |
| `FieldsFunc(s string, f func(rune) bool) []string`       | 按照函数定义的要求将字符换分割成列表                         |
| `HasPrefix(s, prefix string) bool`                       | 字符串前缀是否为子串                                         |
| `HasSuffix(s, suffix string) bool`                       | 字符串后缀是否为子串                                         |
| `Index(s, substr string) int`                            | 查找子串在字符串中的位置(不存在返回-1)                       |
| `IndexAny(s, chars string) int`                          | 查找子串中任一字符在字符串中第一次出现的位置(不存在返回-1)   |
| `IndexByte(s string, c byte) int`                        | 查找字符在字符串中第一次出现的位置(第一次出现返回-1)         |
| `IndexFunc(s string, f func(rune) bool) int`             | 找到第一个能让函数返回true的位置                             |
| `IndexRune(s string, r rune) int`                        | 找到第一个符合要求的字符的位置                               |
| `Join(a []string, sep string) string`                    | 将字符串列表合成字符串                                       |
| `LastIndex(s, substr string) int`                        | 找到最后一个符合要求的子串位置                               |
| `LastIndexAny(s, chars string) int`                      | 找到最后一个在存在于子串中的字符在字符串中的位置             |
| `LastIndexByte(s string, c byte) int`                    | 找到最后一个符合要求的字符在字符串中的位置                   |
| `LastIndexFunc(s string, f func(rune) bool) int`         | 找到最后一个能让函数返回true的位置                           |
| `Map(mapping func(rune) rune, s string) string`          | 按照函数转换每个字符串的字符                                 |
| `Repeat(s string, count int) string`                     | 将字符串重复count遍                                          |
| `Replace(s, old, new string, n int) string`              | 将字符串中的指定子串替换成别的子串                           |
| `Split(s, sep string) []string`                          | 按照特定的子串将字符串分割成字符串列表                       |
| `SplitAfter(s, sep string) []string`                     | 在指定子串后将字符串分割成字符串列表(会保留用于分隔的子串)   |
| `SplitAfterN(s, sep string, n int) []string`             | 在指定子串后将字符串分割成字符串列表(会保留用于分隔的子串,且列表长度不大于n) |
| `SplitN(s, sep string, n int) []string`                  | 使用指定子串将字符串分割成字符串列表(列表长度不大于n)        |
| `Title(s string) string`                                 | 所有单词首字母转换成标题格式(大写)                           |
| `ToLower(s string) string`                               | 将字符串转换为小写                                           |
| `ToLowerSpecial(c unicode.SpecialCase, s string) string` | 将特殊编码的字符串转换为小写                                 |
| `ToTitle(s string) string`                               | 所有单词转换成标题格式(大写)                                 |
| `ToTitleSpecial(c unicode.SpecialCase, s string) string` | 将特殊编码的字符串转换为标题格式                             |
| `ToUpper(s string) string`                               | 字符串转换为大写                                             |
| `ToUpperSpecial(c unicode.SpecialCase, s string) string` | 将特殊编码的字符串转换为大写                                 |
| `Trim(s string, cutset string) string`                   | 将字符串两端在删除集合的字符删去                             |
| `TrimFunc(s string, f func(rune) bool) string`           | 将字符串两端能将函数返回true的字符删去                       |
| `TrimLeft(s string, cutset string) string`               | 将字符串开头在删除集合内字符删去                             |
| `TrimLeftFunc(s string, f func(rune) bool) string`       | 将字符串开头能将函数返回true的字符删去                       |
| `TrimPrefix(s, prefix string) string`                    | 删除字符串前面的前缀字符串(如果有这个前缀)                   |
| `TrimRight(s string, cutset string) string`              | 将字符串结尾在删除集合内的字符删去                           |
| `TrimRightFunc(s string, f func(rune) bool) string`      | 将字符串结尾能将函数返回true的字符删去                       |
| `TrimSpace(s string) string`                             | 删除字符串两端的空白字符                                     |
| `TrimSuffix(s, suffix string) string`                    | 删除字符串后面的后缀字符串(如果有这个后缀)                   |



Golang的双引号和反引号都可用于表示一个常量字符串，不同在于：

- 双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行)
- 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式



```go
const (
	变量
)

var (
	变量
)

type (
  user struct{
    
  }
  ...
)
```



将数组转换为切片 s := arr[:]



```go
const (
 a int = iota
 b
 c
 d string = "1"
 e
)
```

a,b,c 都为 int类型 ; d,e 都为string类型



**channel通信控制基于CSP模型，相比于传统的线程与锁并发模型，避免了大量的加锁解锁的性能消耗，而又比Actor模型更加灵活，使用Actor模型时，负责通讯的媒介与执行单元是紧耦合的–每个Actor都有一个信箱。**

**而使用CSP模型，channel是第一对象，可以被独立地创建，写入和读出数据，更容易进行扩展。**





Context通常被译作上下文，它是一个比较抽象的概念。

在讨论链式调用技术时也经常会提到上下文。

上下文则几乎已经成为传递与请求同生存周期变量的标准方法。

一般理解为程序单元的一个运行状态、现场、快照，而翻译中上下又很好地诠释了其本质，上下则是存在上下层的传递，上会把内容传递给下。

在Go语言中，程序单元也就指的是Goroutine。



每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中。



在网络编程下，当接收到一个网络请求Request，在处理这个Request的goroutine中，可能需要在当前gorutine继续开启多个新的Goroutine来获取数据与逻辑处理（例如访问数据库、RPC服务等），即一个请求Request，会需要多个Goroutine中处理。

而这些Goroutine可能需要共享Request的一些信息；

同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。



Context的创建和调用关系是层层递进的，也就是我们通常所说的链式调用，类似数据结构里的树，从根节点开始，每一次调用就衍生一个叶子节点。

父Context 调用 cancel 方法,所有子Context的Done管道都会传进值

首先，生成根节点，使用context.Background方法生成，而后可以进行链式调用使用context包里的各类方法，context包里的所有方法：

- func Background() Context
- func TODO() Context
- func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
- func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
- func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
- func WithValue(parent Context, key, val interface{}) Context



Context就是设计用来解决那种多个goroutine处理一个Request且这多个goroutine需要共享Request的一些信息的场景



首先调用context.Background()生成根节点，然后调用withCancel方法，传入根节点，得到新的子Context以及根节点的cancel方法（通知所有子节点结束运行）

这里要注意：该方法也返回了一个Context，这是一个新的子节点，与初始传入的根节点不是同一个实例了，但是每一个子节点里会保存从最初的根节点到本节点的链路信息 ，才能实现链式。



中间每个ctx都可以通过WithValue方式传值（实现通信），而每一个子goroutine都能通过Value方法从父goroutine取值，实现协程间的通信

每个子ctx可以调用Done方法检测是否有父节点调用cancel方法通知子节点退出运行，根节点的cancel调用会沿着链路通知到每一个子节点，因此实现了强并发控制

![Context调用链路](缺点/044svco84sif9rjebqagmar0fp.png)

处理Request的goroutine启动多个子goroutine大多是处理IO密集的任务如读写数据库或rpc调用，然后在主goroutine中继续执行其他逻辑



以下是一些Context使用的规范：

- 不要把Context存在一个结构体当中，显式地传入函数。Context变量需要作为第一个参数使用，一般命名为ctx；
- 即使方法允许，也不要传入一个nil的Context，如果你不确定你要用什么Context的时候传一个context.TODO；
- 使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数；
- 同样的Context可以用来传递到不同的goroutine中，Context在多个goroutine中是安全的；



Goland 并发实现

1. goruntine: 程序并发执行
2. channel: 多个goruntine间的数据同步和通信
3. select: 多个channel选择数据读取或者写入



在main包中只有当实在不可运行的情况采用panic，例如文件无法打开，数据库无法连接导致程序无法 正常运行，

但是对于其他的package对外的接口不能有panic，只能在包内采用。 



**建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序。**

**但是log.Fatal直接使用os.Exit退出程序 , 无法等到defer的调用**

**panic 可以等到defer的调用**



recover用于捕获runtime的异常，禁止滥用recover，在开发测试阶段尽量不要用recover，recover一般放在你认为会有不可预期的异常的地方。



方法的接收器

名称 一般采用strcut的第一个字母且为小写，而不是this，me或者self

如果接收者是map,slice或者chan，不要用指针传递



Go1.9中增加了类型别名这个语法，类型别名可以更优雅的实现当两个包之间struct的移动。类型别名的语法如下：

```
type T1 = T2
```



delete(map,key)

value,ok := map[key]



```go
type user struct {
 name    string
 sex     bool
 address struct {
  city string
  no   int
 }
 inter interface {
  say()
 }
}

u := &user{name: "Simon", address: struct {
city string
no   int
}{city: "QHD", no: 1}, inter: nil}
fmt.Println(u.address.city)

m := map[user]string{user{}: "1"}
```



node只适合IO密集型，它没有提供太多的并发基元。唯一能同时运行的是I/O程序和定时器等，并不适合CPU密集型。

go适合IO密集型同样也适合CPU密集型，你可以在程序运行的任何阶段，创建goruntine去实现并发，并且go提供了channel来实现协程间通信，很赞有木有。



#### Pop/Shift

```
x, a = a[0], a[1:]
```

*一行实现 pop 出队列头。*

#### Pop Back

```
x, a = a[len(a)-1], a[:len(a)-1]
```

*一行实现 pop 出队列尾。*

#### Push

```
a = append(a, x)
```

*push x 到队列尾。*

#### Push Front/Unshift

```
a = append([]T{x}, a...)
```

*push x 到队列头。*



close一个从来没有传过值的channel,会往该channel中传进一个默认值(bool->false, int->0)

```go
done := make(chan bool,1)
go func() {
 for {
  select {
  case r := <-done:
   fmt.Println(r)
   return
  }
 }
}()

close(done)
// => false
```

go run file.go 只能执行包含 main 方法的文件



数组长度不一样是两种不同的类型



type iAdder func(int) (int, iAdder)



数组在函数间进行传递会进行完成复制操作，这样不利于优化内存和性能，比较好的一种做法是使用指针，将数组的地址传入函数，此时只需要分配8字节的内存给指针就可以了

注意：函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是 会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25% 的容量。随着语言的演化，这种增长算法可能会有所改变。



在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量 字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片 复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底 层数组，在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指 针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。



如果两个或者多个 goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（racecandition）。对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个goroutine对共享资源进行读和写操作。



一种修正代码、消除竞争状态的办法是，使用 Go 语言提供的锁机制，来锁住共享资源，从 而保证 goroutine 的同步状态。Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。如果需要顺序访问一个 整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。



goroutine 只是由官方实现的超级“线程池”而已。



　**进程、线程 和 协程 之间概念的区别**

　对于 **进程、线程**，都是有内核进行调度，有 CPU 时间片的概念，进行 **抢占式调度**（有多种调度算法）

　对于 **协程**(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 **协作式调度**，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。

**本质上，goroutine 就是协程。** 



不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。

Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。



内存消耗方面

每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。
　　　　*goroutine：*2KB 
　　　　线程：8MB

线程和 goroutine 切换调度开销方面

　　线程/goroutine 切换开销方面，goroutine 远比线程小
　　　　*线程：*涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。
　　　　*goroutine：*只有三个寄存器的值修改 - PC / SP / DX.



线程是操作系统的内核对象，多线程编程时，如果线程数过多，就会导致频繁的上下文切换，这些 cpu 时间是一个额外的耗费。

所以在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 连接是很不明智的。

于是操作系统提供了基于事件模式的异步编程模型。

用少量的线程来服务大量的网络连接和I/O操作。

但是采用异步和基于事件的编程模型，复杂化了程序代码的编写，非常容易出错。

因为线程穿插，也提高排查错误的难度。





协程，是在应用层模拟的线程，他避免了上下文切换的额外耗费，兼顾了多线程的优点。

简化了高并发程序的复杂度。

举个例子，一个高并发的网络服务器，每一个socket连接进来，服务器用一个协程来对他进行服务。代码非常清晰。而且兼顾了性能。



 **那么，协程是怎么实现的呢？**

　　他和线程的原理是一样的，当 a线程 切换到 b线程 的时候，需要将 a线程 的相关执行进度压入栈，然后将 b线程 的执行进度出栈，进入 b线程 的执行序列。

协程只不过是在 应用层 实现这一点。

但是，协程并不是由操作系统调度的，而且应用程序也没有能力和权限执行 cpu 调度。怎么解决这个问题？

答案是，协程是基于线程的。

内部实现上，维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。

这就解决了协程的执行问题。那么协程是怎么切换的呢？

答案是：golang 对各种 io函数 进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 io函数，当这些异步函数返回 busy 或 bloking 时，golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。

包括 linux 的 epoll、select 和 windows 的 iocp、event 等。



由于golang是从编译器和语言基础库多个层面对协程做了实现，所以，golang的协程是目前各类有协程概念的语言中实现的最完整和成熟的。

十万个协程同时运行也毫无压力。关键我们不会这么写代码。但是总体而言，程序员可以在编写 golang 代码的时候，可以更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。



协程（Coroutine）是在1963年由Melvin E. Conway USAF, Bedford, MA等人提出的一个概念。而且协程的概念是早于线程（Thread）提出的。

但是由于协程是**非抢占式**的调度，无法实现公平的任务调用。也无法直接利用多核优势。因此，我们不能武断地说协程是比线程更高级的技术。



尽管，在任务调度上，协程是弱于线程的。

但是在资源消耗上，协程则是极低的。

一个线程的内存在 MB 级别，而协程只需要 KB 级别。

而且线程的调度需要内核态与用户的频繁切入切出，资源消耗也不小。

我们把协程的基本特点归纳为：

```
`1. 协程调度机制无法实现公平调度``2. 协程的资源开销是非常低的，一台普通的服务器就可以支持百万协程。`
```



那么，近几年为何协程的概念可以大热。

我认为一个特殊的场景使得协程能够广泛的发挥其优势，并且屏蔽掉了劣势 --> 网络编程。

与一般的计算机程序相比，网络编程有其独有的特点。

```
`1. 高并发（每秒钟上千数万的单机访问量）``2. Request/Response。程序生命期端（毫秒，秒级）``3. 高IO，低计算（连接数据库，请求API）。`
```

最开始的网络程序其实就是一个线程一个请求设计的（Apache）。

后来，随着网络的普及，诞生了C10K问题。Nginx 通过单线程异步 IO 把网络程序的执行流程进行了乱序化，通过 IO 事件机制最大化的保证了CPU的利用率。

至此，现代网络程序的架构已经形成。基于IO事件调度的异步编程。其代表作恐怕就属 `NodeJS `了吧。



在工程上，有两种最常见的并发通信模型：**共享内存** 和 **消息**。

使用了锁变量（属于一种共享内存）来同步协程，事实上 Go 语言主要使用消息机制（channel）来作为通信模型



在UNIX中，select()函数用来监控一组描述符，该机制常被用于实现高并发的socket服务器程序。

Go语言直接在语言级别支持select关键字，用于处理异步IO问题



select默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的。



`\r` 代表输入到行首



select 中的case 可以使用断言

```
case e, ok := <-ch1
```



go 语言的执行顺序

1. 其他包中所有文件的包一级变量初始化函数
2. 其他包中所有文件的init函数
3. 本包中的包一级变量初始化函数
4. 本包中的init函数,队列模型
5. 本包中的main函数
6. 本包中的defer函数,栈模型