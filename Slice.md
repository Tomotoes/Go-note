# Slice

在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量 字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片 复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底 层数组，在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指 针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。



将数组转换为切片 s := arr[:]

切片容量必须大于切片长度



slice可以先后扩展,不可以向前扩展

s[i] 不可以超越len(s),向后扩展不可以超越底层数组cap(s)

```go
arr := [...]int{0,1,2,3,4,5,6,7}
s1 := arr[2:6]
s2 := s1[3:5]
```



1. 将切片 b 的元素追加到切片 a 之后：`a = append(a, b...)`

2. 复制切片 a 的元素到新的切片 b 上：

   ```
   b = make([]T, len(a))
   copy(b, a)
   ```

3. 删除位于索引 i 的元素：`a = append(a[:i], a[i+1:]...)`

4. 切除切片 a 中从索引 i 至 j 位置的元素：`a = append(a[:i], a[j:]...)`

5. 为切片 a 扩展 j 个元素长度：`a = append(a, make([]T, j)...)`

6. 在索引 i 的位置插入元素 x：`a = append(a[:i], append([]T{x}, a[i:]...)...)`

7. 在索引 i 的位置插入长度为 j 的新切片：`a = append(a[:i], append(make([]T, j), a[i:]...)...)`

8. 在索引 i 的位置插入切片 b 的所有元素：`a = append(a[:i], append(b, a[i:]...)...)`

9. 取出位于切片 a 最末尾的元素 x：`x, a = a[len(a)-1], a[:len(a)-1]`

10. 将元素 x 追加到切片 a：`a = append(a, x)`



string 可以使用切片 , string 不能根据索引的方式赋值



如果某个人写：`var slice1 []type = arr1[:]` 那么 slice1 就等于完整的 arr1 数组

（所以这种表示方式是 `arr1[0:len(arr1)]` 的一种缩写）。

另外一种表述方式是：`slice1 = &arr1`。



`arr1[2:]` 和 `arr1[2:len(arr1)]` 相同，都包含了数组从第三个到最后的所有元素。

`arr1[:3]` 和 `arr1[0:3]` 相同，包含了从第一个到第三个元素（不包括第四个）。



#### Pop/Shift

```
x, a = a[0], a[1:]
```

*一行实现 pop 出队列头。*

#### Pop Back

```
x, a = a[len(a)-1], a[:len(a)-1]
```

*一行实现 pop 出队列尾。*

#### Push

```
a = append(a, x)
```

*push x 到队列尾。*

#### Push Front/Unshift

```
a = append([]T{x}, a...)
```

*push x 到队列头。*