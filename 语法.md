### 关键字

```go
- break        default           func        interface        select
- case          defer              go           map               struct
- chan          else                goto       package        switch
- const         fallthrough    if             range             type
- continue   for                  import    return             var 
```



### 注释

```go
//   单行注释
/* */  多行注释
```


### 函数

>  func (宿主) 函数名(参数) (返回值)



type MyInt int

type MyInt = int

import alias package



map

len

range

make

defer

go

append



大写方法名，才可被外部包调用



方法内部才可以使用 简易定义 

`a:=xxx`



系统方法一般最后一个参数返回 error

原始的处理错误机制



数组可以直接 `==` 、`!=` ， 不可以 `> <`



省略小括号，不省略大括号



数组，结构体初始化 都使用大括号。。。



函数多个返回值时可以用"_"忽略返回值

```
 a, _, c, d := 1, 3, 4
```



#### 类型转换

- go中不存在隐式转换，所有类型转换必须显示声明
- 转换只能发生在两种相互兼容的类型之间
- 类型转换的格式:

```
var a float32 = 1.1
b := int(a)
```





#### 常量的初始化规则

- 在定义常量组时，如果不提供初始值，则表示使用上行的表达式

```
 var a = 1
 const (
    b  = a
    //此时报错，因为全局变量在编译时不能确定值，常量必须是编译时能确定值的或使用内置函数获得的值(eg:len())
 )
 
 const (
    a = "A"
    b
    c
    //此时 a,b,c都为"A"
 )
 
 const (
    a, b = 1, "A"
    c, d
    //a,c为1，b,d为"A"。此时注意下行的常量个数必须与上行数量保持一致
 )
```



#### 常量的枚举

- 使用相同的表达式不代表具有相同的值
- iota是常量的计数器，从0开始，组中每定义1个常量自动递增1
- 通过初始化规则与iota可以达到枚举的效果
- 每遇到一个const关键字，iota就会重置为0

```
const (
    a = "A"
    b
    c = iota
    d        //d的值为3，因为在常量组中，定义了4个变量所以iota计数器从0开始计数4次，所以为3
)
```



#### 指针

go虽然保留了指针，但是与其它编程语言不同的是，在go当中不支持指针运算以及"->"运算符，而直接采用"." 选择符来操作指针目标对象的成员

> - 操作符"&"取变量地址，使用"*"通过指针间接访问目标对象

> - 默认值为nil而非null

在go中，++与--是作为语句而并不是作为表达式

```go
a := 1
a++
//但不能这样：a := a++，只能作为单独的语句独占一行
```



#### if判断语句

- 条件表达式没有括号
- 支持一个初始化表达式(可以是并行方式)
- 左大括号必须和条件语句或else在同一行
- 支持单行模式
- 初始化语句中的变量为block级别，同时隐藏外部同名变量



#### for循环语句

- go只有for一个循环语句关键字，但支持3种形式

```
//第一种(同其他语言的while true {})：
func main() {
  a := 1
  for {
      a++
      if a > 3{
          break
      }
  }
  fmt.Println(a)
}
//第二种(同其他语言的:while a <= 3 {})：  
func main() {
  a := 1
  for a <= 3 {
     a++
  }
  fmt.Println(a)
}
//第三种：
func main() {
  a := 1
  for i := 0; i <= 3; i++ {
     a++
  }
  fmt.Println(a)
}
```



#### witch选择语句

go语言中无须对每个case手动书写break以阻止程序继续向下匹配。如果要达到继续匹配的目的可以使用关键字：fallthrough

```go
func main() {
  a := 1
  switch a {
      case 0:
        fmt.Println("a=0")
      case 1:
        fmt.Println("a=1")
  }
  fmt.Println(a)
}
  
func main() {
  a := 1
  switch {
      case a >= 0:
        fmt.Println("a=0")
        fallthrough
      case a >= 1:
        fmt.Println("a=1")
  }
  fmt.Println(a)
}

//此时a的作用域只在switch表达式之内
func main() {
  
  switch a := 1 {
      case a >= 0:
        fmt.Println("a=0")
        fallthrough
      case a >= 1:
        fmt.Println("a=1")
  }
  fmt.Println(a)
}
```

#### array的定义

- 定义数组的格式:

```
var a[4]int  //元素自动初始化为零

a := [...]int{19:1}  //编译器按照初始化值数量确定数组长度

a := [5]int{1,2}  //未提供初始值的元素自动初始化为零
```

- 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型
- 数组在go中为值类型

#### 2.数组指针和指针数组

```
//数组指针是指获取数组变量的地址。
//此时变量p就是指向数组的指针。特别注意p定义的类型为长度为100的数组的指针。 长度必须相等才能赋值。
func main() {
    var a =  [...]int{99:1}
    var p *[100]int = &a
    fmt.Println(p)
}
  
//指针数组是指元素为指针类型的数组
func main() {
    var x, y = 2, 3
    var a  = [...]*int{&x, &y}
    fmt.Println(a)
}
```

#### 3.数组之间的比较

数组之间可以使用==或！=进行比较，但不可以使用<或>

```
//数组类型必须相同才能比较
func main() {
  a := [2]int{1,2}
  b := [2]int{1,3}
  fmt.Println(a == b)
}
```

#### 4.使用new创建数组，此方法返回一个数组指针

```
func main() {
  p := new([10]int)
  fmt.Println(p)
}
```

#### 5.多维数组

```
func main() {
    a := [2][3]int{
        {1,2,3},
        {4,5,6}
    }
    b := [2][3]int{
        {1:1},
        {2:2}
    }
    c := [...][3]int{
        {1:1},
        {2:2}
    } 
}
```



只有 package 名称为 main 的包可以包含 main 函数

一个可执行程序 有且仅有一个 main 包



**同一路径下，只能有一个包文件**



通过 import 关键字来导入其他非 main 包

const 定义常量

在函数体外 使用 var 关键字来 定义全局变量

通过 type 关键字来进行 结构体 或 接口的声明



类型转换

`<ValueA> [:]= <TypeOfValueA>(<ValueB>) `



rune 就是 int32



切片

```
a := [...]int{3, 2, 1, 19: 1} 

s1:=a[5:]//a[5,6,7,8,9]
s1:=a[:5]//a[5,6,7,8,9]
sb := a[3:5]
```



`_` 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。



下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

之所以刻意地将 Go 代码中的关键字保持的这么少，是为了简化在编译过程第一步中的代码解析。和其它语言一样，关键字不能够作标识符使用。

除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数（第 6.5 节），它们的作用都将在接下来的章节中进行进一步地讲解。

| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |
| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |

程序一般由关键字、常量、变量、运算符、类型和函数组成。



**如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。**



```
const (
 a = iota
 b = iota
 c = iota
)

const (
 d = iota
 e
 g
)
作用相同
```



当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。



一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写



_ 实际上是一个只写变量



这些类型的长度都是根据运行程序所在的操作系统类型所决定的：

- `int` 和 `uint` 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。
- `uintptr` 的长度被设定为足够存放一个指针即可。

Go 语言中没有 float 类型。

与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：

整数：

- int8（-128 -> 127）
- int16（-32768 -> 32767）
- int32（-2,147,483,648 -> 2,147,483,647）
- int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）

无符号整数：

- uint8（0 -> 255）
- uint16（0 -> 65,535）
- uint32（0 -> 4,294,967,295）
- uint64（0 -> 18,446,744,073,709,551,615）

浮点型（IEEE-754 标准）：

- float32（+- 1e-45 -> +- 3.4 * 1e38）
- float64（+- 5 * 1e-324 -> 107 * 1e308）

int 型是计算最快的一种类型。

整型的零值为 0，浮点型的零值为 0.0。

float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 `==` 或者 `!=` 来比较浮点数时应当非常小心。你最好在正式使用前测试对于精确度要求较高的运算。

你应该尽可能地使用 float64，因为 `math` 包中所有有关数学运算的函数都会要求接收这个类型。



Go 拥有以下复数类型：

```
complex64 (32 位实数和虚数)
complex128 (64 位实数和虚数)
```

复数使用 `re+imI` 来表示，其中 `re` 代表实数部分，`im` 代表虚数部分，I 代表根号负 1。

示例：

```
var c1 complex64 = 5 + 10i
fmt.Printf("The value is: %v", c1)
// 输出： 5 + 10i
```

如果 `re` 和 `im` 的类型均为 float32，那么类型为 complex64 的复数 c 可以通过以下方式来获得：

```
c = complex(re, im)
```

函数 `real(c)` 和 `imag(c)` 可以分别获得相应的实数和虚数部分。

在使用格式化说明符时，可以使用 `%v` 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 `%f`。



`byte` 类型是 `uint8` 的别名	



你可以通过以下方式来对代码中多行的字符串进行拼接：

```
str := "Beginning of the string " +
	"second part of the string"
```



go 和 js 一样支持标签 

```go
LABEL:
	for i := 1; i <= 100; i++ {
		for j := 1; j <= 10; j++ {
				if j == 2{
					break LABEL
				}
				fmt.Println(1)
		}
	}
	fmt.Println(2)
```



一个函数中只支持一个变长参数 , 且必须放到最后一位!

对应的函数调用中,  可以使用多个类型相同的变量, 也可使用`slice...`



数组可以和结构体 一样, 单个赋值

```go
arr := [5]int{1:2,4:5}
//[0 2 0 0 5]
fmt.Println(arr)
```



string 可以使用切片 , string 不能根据索引的方式赋值

**不要使用 new，永远用 make 来构造 map**



切片提供了计算容量的函数 `cap()` 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。

如果 s 是一个切片，`cap(s)` 就是从 `s[0]` 到数组末尾的数组长度。

切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：`0 <= len(s) <= cap(s)`。



如果某个人写：`var slice1 []type = arr1[:]` 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 `arr1[0:len(arr1)]` 的一种缩写）。

另外一种表述方式是：`slice1 = &arr1`。



`arr1[2:]` 和 `arr1[2:len(arr1)]` 相同，都包含了数组从第三个到最后的所有元素。

`arr1[:3]` 和 `arr1[0:3]` 相同，包含了从第一个到第三个元素（不包括第四个）。

如果你想去掉 slice1 的最后一个元素，只要 `slice1 = slice1[:len(slice1)-1]`。